import type { ConstRoute, PagesType } from '@better-pages-create/core'
import { serialize } from '@better-pages-create/shared'

export function generateImportMap(routes: ConstRoute[], type: PagesType): string {
  const imports: string[] = []

  function collectImports(routeList: ConstRoute[]) {
    for (const route of routeList) {
      if (route.matched?.[type]) {
        const importPath = route.matched[type]
        imports.push(`"${route.name}": () => import("${importPath}")`)
      }
      if (route.children) {
        collectImports(route.children)
      }
    }
  }

  collectImports(routes)
  return imports.join(',\n')
}

export function generateReactClientCode(routes: ConstRoute[]) {
  const stringRoutes = serialize(routes)

  const code = `
// Generated by better-pages-create

import React from 'react'

const layouts = {
${generateImportMap(routes, 'layout')}
};

const views = {
${generateImportMap(routes, 'index')}
};

const loadings = {
${generateImportMap(routes, 'loading')}
};

const errors = {
${generateImportMap(routes, 'error')}
};

export function transformRoutesToReactRoutes(routes) {
  return routes.flatMap(route => transformRouteToReactRoute(route));
}

export function transformRouteToReactRoute(route) {
  const { children, matched, name, path, handle } = route;

  function convertConfig(module) {
    const { action, loader, shouldRevalidate, default: Component } = module;
    return {
      action,
      loader, 
      shouldRevalidate,
      Component
    };
  }

  async function getConfig(index = false) {
    if (matched.layout && !index) {
      const config = await layouts[name]();
      return convertConfig(config);
    }

    if (matched.index && (!children?.length || index)) {
      const pageName = name === "notFound" ? "404" : name;
  
      const config = await views[pageName]();
      return convertConfig(config);
    }

    return null;
  }

  function isRouteGroup(name) {
    const lastName = name.split("_").at(-1);
    return lastName?.startsWith("(") && lastName?.endsWith(")");
  }

  function getHandle(index = false) {
    if ((matched.layout || isRouteGroup(name)) && !index) {
      return null;
    }

    return handle;
  }

  async function getComponent(componentMap, key) {
    if (!componentMap[key]) return undefined;
    const module = await componentMap[key]();
    return module.default;
  }

  async function createLazyConfig(isIndex = false) {
    return {
      ErrorBoundary: await getComponent(errors, name || "root"),
      ...(await getConfig(isIndex))
    };
  }

  const loading = loadings[name] ? React.lazy(loadings[name]) : (loadings.root ? React.lazy(loadings.root) : undefined);
  
  const reactRoute = {
    children: [],
    HydrateFallback: loading,
    id: name,
    handle: getHandle(),
    lazy: createLazyConfig,
    path
  };

  if (children?.length) {
    reactRoute.children = children.flatMap(child => transformRouteToReactRoute(child));

    if (matched.index) {
      reactRoute.children.unshift({
        handle: getHandle(true),
        index: true,
        lazy: () => createLazyConfig(true)
      });
    }
  }

  return reactRoute;
}

const routes = ${stringRoutes};

export default transformRoutesToReactRoutes(routes);`

  return code
}
