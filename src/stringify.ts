import type { ResolvedOptions } from './types'
import { ROUTE_IMPORT_NAME } from './constants'

// 导入工具函数
// import { resolveImportMode } from './utils' // 导入模式解析

// 正则表达式：匹配组件或元素属性
const componentRE = /"(?:component|element)":("(.*?)")/g

// 正则表达式：匹配函数属性（如 props、beforeEnter）
const hasFunctionRE = /"(?:props|beforeEnter)":("(.*?)")/g

// 正则表达式：匹配多行注释
const multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//g

// 正则表达式：匹配单行注释
const singlelineCommentsRE = /\/\/.*/g

/**
 * 函数替换器
 * 在 JSON.stringify 过程中处理函数类型的值
 * @param _ - 键名（未使用）
 * @param value - 要处理的值
 * @returns 处理后的值
 */
function replaceFunction(_: any, value: any) {
  if (typeof value === 'function' || typeof value === 'function') {
    // 获取函数体并清理注释和空格
    const fnBody = value.toString()
      .replace(multilineCommentsRE, '') // 移除多行注释
      .replace(singlelineCommentsRE, '') // 移除单行注释
      .replace(/(\s)/g, '') // 移除所有空格

    // 检查是否为 ES6 箭头函数
    if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function')
      return `_NuFrRa_${fnBody}` // 标记箭头函数

    return fnBody // 返回函数体
  }

  return value // 非函数值直接返回
}

export function stringifyRoutes(
  preparedRoutes: any[],
  options: ResolvedOptions,
) {
  const importsMap: Map<string, string> = new Map()

  function getImportString(path: string, importName: string) {
    return `import ${importName} from "${path}"`
  }

  function componentReplacer(str: string, replaceStr: string, path: string) {
    let importName = importsMap.get(path)

    if (!importName) {
      importName = ROUTE_IMPORT_NAME.replace('$1', `${importsMap.size}`)
    }

    importsMap.set(path, importName)

    importName = options.resolver.stringify?.component?.(importName) || importName

    return str.replace(replaceStr, importName)
  }

  function functionReplacer(str: string, replaceStr: string, content: string) {
    if (content.startsWith('function'))
      return str.replace(replaceStr, content)

    if (content.startsWith('_NuFrRa_'))
      return str.replace(replaceStr, content.slice(8))

    return str
  }

  const stringRoutes = JSON
    .stringify(preparedRoutes, replaceFunction)
    .replace(componentRE, componentReplacer)
    .replace(hasFunctionRE, functionReplacer)

  const imports = Array.from(importsMap).map(args => getImportString(...args))

  return {
    imports,
    stringRoutes,
  }
}

export function generateClientCode(routes: any[], options: ResolvedOptions) {
  const { imports, stringRoutes } = stringifyRoutes(routes, options)

  const code = `/* prettier-ignore */
/* eslint-disable */
// Generated by better-pages-create

${imports.join(';\n')};

const loadings = import.meta.glob('/src/pages/**/loading.tsx', { eager: true, import: 'default' });
const errors = import.meta.glob('/src/pages/**/error.tsx', { eager: true, import: 'default' });

/**
 * transform const routes to react routes
 */
export function transformRoutesToReactRoutes(routes) {
  return routes.flatMap(route => transformRouteToReactRoute(route));
}

/**
 * transform single route to react route
 */
export function transformRouteToReactRoute(route) {
  const { children, matched, name, path, handle } = route;

  // Get the error boundary component
  const getErrorComponent = () => (matched.error ? errors[matched.error]() : errors['/src/pages/error.tsx']);

  // Convert route config
  function convertConfig(m) {
    const { action, loader, shouldRevalidate, default: Component } = m;
    return {
      action,
      loader, 
      shouldRevalidate,
      Component
    };
  }

  // Get config for the route
  async function getConfig(index = false) {
    if (matched.layout && !index) {
      const config = await import(/* @vite-ignore */ matched.layout);
      return convertConfig(config);
    }

    if (matched.index && (!children?.length || index)) {
      const config = await import(/* @vite-ignore */ matched.index);
      return convertConfig(config);
    }

    return null;
  }

  const reactRoute = {
    children: [],
    HydrateFallback: matched.loading ? loadings[matched.loading] : loadings['/src/pages/loading.tsx'],
    id: name,
    handle: handle,
    lazy: async () => {
      const ErrorBoundary = await getErrorComponent();
      return {
        ErrorBoundary: ErrorBoundary?.default,
        ...(await getConfig())
      };
    },
    path
  };

  if (children?.length) {
    reactRoute.children = children.flatMap(child => transformRouteToReactRoute(child));

    if (matched.index) {
      reactRoute.children.unshift({
        handle: handle,
        index: true,
        lazy: async () => {
          const ErrorBoundary = await getErrorComponent();
          return {
            ErrorBoundary: ErrorBoundary?.default,
            ...(await getConfig(true))
          };
        }
      });
    }
  }

  return reactRoute;
}

const routes = ${stringRoutes};

export default transformRoutesToReactRoutes(routes);`

  return options.resolver.stringify?.final?.(code) || code
}
