import type { ConstRoute, ResolvedOptions } from '../types'
import { stringifyRoutes } from '../stringify'
import { generateImportMap } from '../utils'

export function generateReactClientCode(routes: ConstRoute[], options: ResolvedOptions) {
  const { imports, stringRoutes } = stringifyRoutes(routes, options)

  const code = `
// Generated by better-pages-create
${imports.join('\n')}

const layouts = {
${generateImportMap(routes, 'layout')}
};

const views = {
${generateImportMap(routes, 'index')}
};

const loadings = {
${generateImportMap(routes, 'loading')}
};

const errors = {
${generateImportMap(routes, 'error')}
};

/**
 * transform const routes to react routes
 */
export function transformRoutesToReactRoutes(routes) {
  return routes.flatMap(route => transformRouteToReactRoute(route));
}

/**
 * transform single route to react route
 */
export function transformRouteToReactRoute(route) {
  const { children, matched, name, path, handle } = route;

  // Convert route config
  function convertConfig(m) {
    const { action, loader, shouldRevalidate, default: Component } = m;
    return {
      action,
      loader, 
      shouldRevalidate,
      Component
    };
  }

  // Get config for the route
  async function getConfig(index = false) {
    if (matched.layout && !index) {
      const config = await layouts[name]();
      return convertConfig(config);
    }

    if (matched.index && (!children?.length || index)) {
      const config = await views[name]();
      return convertConfig(config);
    }

    return null;
  }

  const reactRoute = {
    children: [],
    HydrateFallback: loadings[matched.loading],
    id: name,
    handle: handle,
    lazy: async () => {
      const ErrorBoundary = errors[matched.error];
      return {
        ErrorBoundary: ErrorBoundary?.default,
        ...(await getConfig())
      };
    },
    path
  };

  if (children?.length) {
    reactRoute.children = children.flatMap(child => transformRouteToReactRoute(child));

    if (matched.index) {
      reactRoute.children.unshift({
        handle: handle,
        index: true,
        lazy: async () => {
          const ErrorBoundary = errors[matched.error];
          return {
            ErrorBoundary: ErrorBoundary?.default,
            ...(await getConfig(true))
          };
        }
      });
    }
  }

  return reactRoute;
}

const routes = ${stringRoutes};

export default transformRoutesToReactRoutes(routes);`

  return code
}
