import type { ConstRoute, PagesType, ResolvedOptions } from '../types'
import { stringifyRoutes } from '../stringify'

export function generateImportMap(routes: ConstRoute[], type: PagesType): string {
  const imports: string[] = []

  function collectImports(routeList: any[]) {
    for (const route of routeList) {
      if (route.matched?.[type]) {
        const importPath = route.matched[type]
        imports.push(`"${route.name}": () => import("${importPath}")`)
      }
      if (route.children) {
        collectImports(route.children)
      }
    }
  }

  collectImports(routes)
  return imports.join(',\n')
}

export function generateReactClientCode(routes: ConstRoute[], options: ResolvedOptions) {
  const { stringRoutes } = stringifyRoutes(routes, options)

  const code = `
// Generated by better-pages-create

const layouts = {
${generateImportMap(routes, 'layout')}
};

const views = {
${generateImportMap(routes, 'index')}
};

const loadings = {
${generateImportMap(routes, 'loading')}
};

const errors = {
${generateImportMap(routes, 'error')}
};

export function transformRoutesToReactRoutes(routes) {
  return routes.flatMap(route => transformRouteToReactRoute(route));
}

export function transformRouteToReactRoute(route) {
  const { children, matched, name, path, handle } = route;

  function convertConfig(module) {
    const { action, loader, shouldRevalidate, default: Component } = module;
    return {
      action,
      loader, 
      shouldRevalidate,
      Component
    };
  }

  async function getConfig(index = false) {
    if (matched.layout && !index) {
      const config = await layouts[name]();
      return convertConfig(config);
    }

    let pageName = name;

    if (pageName === "notFound") {
      pageName = "404";
    }

    if (matched.index && (!children?.length || index)) {
      const config = await views[name]();
      return convertConfig(config);
    }

    return null;
  }

  function isRouteGroup(name) {
    const lastName = name.split("_").at(-1);
    return lastName?.startsWith("(") && lastName?.endsWith(")");
  }

  function getHandle(index = false) {
    if ((matched.layout || isRouteGroup(name)) && !index) {
      return null;
    }

    return handle;
  }

  const reactRoute = {
    children: [],
    HydrateFallback: loadings[matched.loading],
    id: name,
    handle: getHandle(),
    lazy: async () => {
      const ErrorBoundary = errors[matched.error];
      return {
        ErrorBoundary: ErrorBoundary?.default,
        ...(await getConfig())
      };
    },
    path
  };

  if (children?.length) {
    reactRoute.children = children.flatMap(child => transformRouteToReactRoute(child));

    if (matched.index) {
      reactRoute.children.unshift({
        handle: getHandle(true),
        index: true,
        lazy: async () => {
          const ErrorBoundary = errors[matched.error];
          return {
            ErrorBoundary: ErrorBoundary?.default,
            ...(await getConfig(true))
          };
        }
      });
    }
  }

  return reactRoute;
}

const routes = ${stringRoutes};

export default transformRoutesToReactRoutes(routes);`

  return code
}
