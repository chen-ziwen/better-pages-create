import type { ConstRoute, ResolvedOptions } from '../types'
import { stringifyRoutes } from '../stringify'

function generateImportMap(routes: ConstRoute[], type: 'layout' | 'index' | 'loading' | 'error'): string {
  const imports: string[] = []

  function collectImports(routeList: any[]) {
    for (const route of routeList) {
      if (route.matched?.[type]) {
        const importPath = route.matched[type]
        imports.push(`"${route.name}": () => import("${importPath}")`)
      }
      if (route.children) {
        collectImports(route.children)
      }
    }
  }

  collectImports(routes)
  return imports.join(',\n')
}

export function generateReactClientCode(routes: ConstRoute[], options: ResolvedOptions) {
  // 使用 stringifyRoutes 处理函数序列化
  const { imports, stringRoutes } = stringifyRoutes(routes, options)

  const code = `
// Generated by better-pages-create
${imports.join('\n')}

const layouts = {
${generateImportMap(routes, 'layout')}
};

const views = {
${generateImportMap(routes, 'index')}
};

const loadings = {
${generateImportMap(routes, 'loading')}
};

const errors = {
${generateImportMap(routes, 'error')}
};

/**
 * transform const routes to react routes
 */
export function transformRoutesToReactRoutes(routes) {
  return routes.flatMap(route => transformRouteToReactRoute(route));
}

/**
 * transform single route to react route
 */
export function transformRouteToReactRoute(route) {
  const { children, matched, name, path, handle } = route;

  // Convert route config
  function convertConfig(m) {
    const { action, loader, shouldRevalidate, default: Component } = m;
    return {
      action,
      loader, 
      shouldRevalidate,
      Component
    };
  }

  // Get config for the route
  async function getConfig(index = false) {
    if (matched.layout && !index) {
      const config = await layouts[name]();
      return convertConfig(config);
    }

    if (matched.index && (!children?.length || index)) {
      const config = await views[name]();
      return convertConfig(config);
    }

    return null;
  }

  const reactRoute = {
    children: [],
    HydrateFallback: matched.loading ? loadings[matched.loading] : undefined,
    id: name,
    handle: handle,
    lazy: async () => {
      const ErrorBoundary = matched.error ? errors[matched.error] : undefined;
      return {
        ErrorBoundary: ErrorBoundary?.default,
        ...(await getConfig())
      };
    },
    path
  };

  if (children?.length) {
    reactRoute.children = children.flatMap(child => transformRouteToReactRoute(child));

    if (matched.index) {
      reactRoute.children.unshift({
        handle: handle,
        index: true,
        lazy: async () => {
          const ErrorBoundary = matched.error ? errors[matched.error] : undefined;
          return {
            ErrorBoundary: ErrorBoundary?.default,
            ...(await getConfig(true))
          };
        }
      });
    }
  }

  return reactRoute;
}

const routes = ${stringRoutes};

export default transformRoutesToReactRoutes(routes);`

  return code
}
